# PenTest CLI Tool

"""
A fully working CLI penetration testing tool with modular features and visually appealing output.

Features:
- Port scanning (TCP)
- Service detection (banner grabbing)
- HTTP info
- Whois lookup
- DNS info
- Colorized output

More features can be added modularly.
"""

import socket
import requests
import sys
import colorama
from colorama import Fore, Style
import argparse

colorama.init(autoreset=True)

BANNER = f"""
{Fore.RED}██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗
{Fore.RED}██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝
{Fore.YELLOW}██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║   
{Fore.YELLOW}██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║   
{Fore.GREEN}██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║   
{Fore.GREEN}╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝   
{Style.RESET_ALL}
"""

import threading
import time

class PenTestTool:
    def __init__(self, target, ports=None, udp_ports=None, scan_speed=0.5, log_file=None):
        self.target = target
        self.ports = ports if ports else [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 8080]
        self.udp_ports = udp_ports if udp_ports else [53, 67, 68, 69, 123, 161, 500]
        self.scan_speed = scan_speed
        self.open_ports = []
        self.open_udp_ports = []
        self.results = {}
        self.log_file = log_file

    def log(self, message):
        print(message)
        if self.log_file:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(message + '\n')

    def port_scan(self):
        self.log(f"{Fore.CYAN}Scanning {self.target} for open TCP ports...{Style.RESET_ALL}")
        for port in self.ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.scan_speed)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    self.log(f"{Fore.GREEN}[+] TCP Port {port} is open")
                    self.open_ports.append(port)
                sock.close()
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Error scanning TCP port {port}: {e}")
            time.sleep(self.scan_speed)
        self.results['open_ports'] = self.open_ports

    def udp_scan(self):
        self.log(f"{Fore.CYAN}Scanning {self.target} for open UDP ports...{Style.RESET_ALL}")
        for port in self.udp_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(self.scan_speed)
                sock.sendto(b"ping", (self.target, port))
                try:
                    data, _ = sock.recvfrom(1024)
                    self.log(f"{Fore.GREEN}[+] UDP Port {port} is open (response received)")
                    self.open_udp_ports.append(port)
                except socket.timeout:
                    self.log(f"{Fore.YELLOW}[?] UDP Port {port} no response (could be open/filtered)")
                sock.close()
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Error scanning UDP port {port}: {e}")
            time.sleep(self.scan_speed)
        self.results['open_udp_ports'] = self.open_udp_ports

    def banner_grab(self):
        banners = {}
        for port in self.open_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                sock.connect((self.target, port))
                sock.send(b'\r\n')
                banner = sock.recv(1024).decode(errors='ignore')
                sock.close()
                if banner:
                    self.log(f"{Fore.MAGENTA}Banner for port {port}: {banner.strip()}{Style.RESET_ALL}")
                    banners[port] = banner.strip()
                else:
                    self.log(f"{Fore.MAGENTA}No banner received for port {port}.{Style.RESET_ALL}")
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Banner grab failed for port {port}: {e}")
        self.results['banners'] = banners

    def http_info(self):
        try:
            url = f"http://{self.target}"
            self.log(f"{Fore.CYAN}Fetching HTTP info for {url}...{Style.RESET_ALL}")
            resp = requests.get(url, timeout=3)
            self.log(f"{Fore.GREEN}Status: {resp.status_code}")
            self.log(f"Headers:")
            for k, v in resp.headers.items():
                self.log(f"  {Fore.YELLOW}{k}: {Fore.WHITE}{v}")
            self.results['http'] = {'status': resp.status_code, 'headers': dict(resp.headers)}
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] HTTP info failed: {e}")

    def dns_lookup(self):
        try:
            self.log(f"{Fore.CYAN}Performing DNS lookup for {self.target}...{Style.RESET_ALL}")
            ip = socket.gethostbyname(self.target)
            self.log(f"{Fore.GREEN}IP Address: {ip}{Style.RESET_ALL}")
            self.results['dns'] = ip
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] DNS lookup failed: {e}")

    def whois_lookup(self):
        try:
            self.log(f"{Fore.CYAN}Performing WHOIS lookup for {self.target}...{Style.RESET_ALL}")
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("whois.iana.org", 43))
            s.send((self.target + "\r\n").encode())
            response = b""
            while True:
                data = s.recv(4096)
                if not data:
                    break
                response += data
            s.close()
            self.log(f"{Fore.GREEN}WHOIS info:\n{response.decode(errors='ignore')}{Style.RESET_ALL}")
            self.results['whois'] = response.decode(errors='ignore')
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] WHOIS lookup failed: {e}")

    def advanced_service_detection(self):
        # Protocol-specific checks (simple)
        for port in self.open_ports:
            try:
                if port == 80 or port == 8080 or port == 443:
                    self.log(f"{Fore.CYAN}Checking HTTP(S) service on port {port}...{Style.RESET_ALL}")
                    try:
                        resp = requests.get(f"http://{self.target}:{port}", timeout=3)
                        self.log(f"{Fore.GREEN}HTTP {port} status: {resp.status_code}")
                    except Exception as e:
                        self.log(f"{Fore.YELLOW}HTTP check failed: {e}")
                elif port == 21:
                    self.log(f"{Fore.CYAN}Checking FTP service on port 21...{Style.RESET_ALL}")
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(2)
                        sock.connect((self.target, 21))
                        banner = sock.recv(1024).decode(errors='ignore')
                        self.log(f"{Fore.GREEN}FTP banner: {banner.strip()}")
                        sock.close()
                    except Exception as e:
                        self.log(f"{Fore.YELLOW}FTP check failed: {e}")
                # Add more protocol checks as needed
            except Exception as e:
                self.log(f"{Fore.YELLOW}Service detection error: {e}")

    def cve_lookup(self):
        # Simulated CVE lookup (real implementation would use an API)
        self.log(f"{Fore.CYAN}Checking for known vulnerabilities (CVE) for detected services...{Style.RESET_ALL}")
        for port, banner in self.results.get('banners', {}).items():
            if 'Apache' in banner:
                self.log(f"{Fore.RED}Potential CVEs for Apache detected on port {port}: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=apache")
            elif 'nginx' in banner:
                self.log(f"{Fore.RED}Potential CVEs for nginx detected on port {port}: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=nginx")
            elif 'OpenSSH' in banner:
                self.log(f"{Fore.RED}Potential CVEs for OpenSSH detected on port {port}: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=openssh")
            # Add more banner checks as needed

    def subdomain_enum(self):
        self.log(f"{Fore.CYAN}Enumerating subdomains...{Style.RESET_ALL}")
        common_subdomains = ['www', 'mail', 'ftp', 'test', 'dev', 'api']
        found = []
        for sub in common_subdomains:
            subdomain = f"{sub}.{self.target}"
            try:
                ip = socket.gethostbyname(subdomain)
                self.log(f"{Fore.GREEN}Found subdomain: {subdomain} -> {ip}")
                found.append(subdomain)
            except Exception:
                pass
        self.results['subdomains'] = found

    def web_bruteforce(self):
        self.log(f"{Fore.CYAN}Brute-forcing common web directories/files...{Style.RESET_ALL}")
        wordlist = ['admin', 'login', 'dashboard', 'robots.txt', 'config', 'uploads']
        found = []
        for word in wordlist:
            url = f"http://{self.target}/{word}"
            try:
                resp = requests.get(url, timeout=2)
                if resp.status_code == 200:
                    self.log(f"{Fore.GREEN}Found: {url}")
                    found.append(url)
            except Exception:
                pass
        self.results['web_bruteforce'] = found

    def detailed_https_info(self):
        import ssl
        self.log(f"{Fore.CYAN}Fetching HTTPS certificate info...{Style.RESET_ALL}")
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target, 443), timeout=3) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    self.log(f"{Fore.GREEN}SSL Certificate:")
                    for k, v in cert.items():
                        self.log(f"  {Fore.YELLOW}{k}: {Fore.WHITE}{v}")
        except Exception as e:
            self.log(f"{Fore.YELLOW}SSL cert info failed: {e}")

    def dns_enum(self):
        import dns.resolver
        self.log(f"{Fore.CYAN}Enumerating DNS records...{Style.RESET_ALL}")
        record_types = ['A', 'MX', 'TXT', 'NS']
        for rtype in record_types:
            try:
                answers = dns.resolver.resolve(self.target, rtype)
                for rdata in answers:
                    self.log(f"{Fore.GREEN}{rtype} record: {rdata}")
            except Exception as e:
                self.log(f"{Fore.YELLOW}{rtype} record lookup failed: {e}")

    def os_detection(self):
        self.log(f"{Fore.CYAN}Attempting OS detection (TCP/IP fingerprinting)...{Style.RESET_ALL}")
        # Simple TTL-based fingerprinting
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((self.target, 80))
            sock.send(b'\r\n')
            ttl = sock.getsockopt(socket.IPPROTO_IP, socket.IP_TTL)
            sock.close()
            if ttl <= 64:
                self.log(f"{Fore.GREEN}Likely Linux/Unix-based OS (TTL={ttl})")
            elif ttl <= 128:
                self.log(f"{Fore.GREEN}Likely Windows-based OS (TTL={ttl})")
            else:
                self.log(f"{Fore.GREEN}Unknown OS (TTL={ttl})")
        except Exception as e:
            self.log(f"{Fore.YELLOW}OS detection failed: {e}")

    def log(self, message):
        print(message)
        if self.log_file:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(message + '\n')

    def port_scan(self):
        self.log(f"{Fore.CYAN}Scanning {self.target} for open TCP ports...{Style.RESET_ALL}")
        for port in self.ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.scan_speed)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    self.log(f"{Fore.GREEN}[+] TCP Port {port} is open")
                    self.open_ports.append(port)
                sock.close()
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Error scanning TCP port {port}: {e}")
            time.sleep(self.scan_speed)
        self.results['open_ports'] = self.open_ports

    def udp_scan(self):
        self.log(f"{Fore.CYAN}Scanning {self.target} for open UDP ports...{Style.RESET_ALL}")
        for port in self.udp_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(self.scan_speed)
                sock.sendto(b"ping", (self.target, port))
                try:
                    data, _ = sock.recvfrom(1024)
                    self.log(f"{Fore.GREEN}[+] UDP Port {port} is open (response received)")
                    self.open_udp_ports.append(port)
                except socket.timeout:
                    self.log(f"{Fore.YELLOW}[?] UDP Port {port} no response (could be open/filtered)")
                sock.close()
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Error scanning UDP port {port}: {e}")
            time.sleep(self.scan_speed)
        self.results['open_udp_ports'] = self.open_udp_ports

    def banner_grab(self):
        banners = {}
        for port in self.open_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                sock.connect((self.target, port))
                sock.send(b'\r\n')
                banner = sock.recv(1024).decode(errors='ignore')
                sock.close()
                if banner:
                    self.log(f"{Fore.MAGENTA}Banner for port {port}: {banner.strip()}{Style.RESET_ALL}")
                    banners[port] = banner.strip()
                else:
                    self.log(f"{Fore.MAGENTA}No banner received for port {port}.{Style.RESET_ALL}")
            except Exception as e:
                self.log(f"{Fore.YELLOW}[!] Banner grab failed for port {port}: {e}")
        self.results['banners'] = banners

    def http_info(self):
        try:
            url = f"http://{self.target}"
            self.log(f"{Fore.CYAN}Fetching HTTP info for {url}...{Style.RESET_ALL}")
            resp = requests.get(url, timeout=3)
            self.log(f"{Fore.GREEN}Status: {resp.status_code}")
            self.log(f"Headers:")
            for k, v in resp.headers.items():
                self.log(f"  {Fore.YELLOW}{k}: {Fore.WHITE}{v}")
            self.results['http'] = {'status': resp.status_code, 'headers': dict(resp.headers)}
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] HTTP info failed: {e}")

    def dns_lookup(self):
        try:
            self.log(f"{Fore.CYAN}Performing DNS lookup for {self.target}...{Style.RESET_ALL}")
            ip = socket.gethostbyname(self.target)
            self.log(f"{Fore.GREEN}IP Address: {ip}{Style.RESET_ALL}")
            self.results['dns'] = ip
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] DNS lookup failed: {e}")

    def whois_lookup(self):
        try:
            self.log(f"{Fore.CYAN}Performing WHOIS lookup for {self.target}...{Style.RESET_ALL}")
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("whois.iana.org", 43))
            s.send((self.target + "\r\n").encode())
            response = b""
            while True:
                data = s.recv(4096)
                if not data:
                    break
                response += data
            s.close()
            self.log(f"{Fore.GREEN}WHOIS info:\n{response.decode(errors='ignore')}{Style.RESET_ALL}")
            self.results['whois'] = response.decode(errors='ignore')
        except Exception as e:
            self.log(f"{Fore.YELLOW}[!] WHOIS lookup failed: {e}")

    def run_all(self):
        self.log(f"{Fore.BLUE}--- Starting Automated PenTest ---{Style.RESET_ALL}")
        self.port_scan()
        self.udp_scan()
        self.banner_grab()
        self.advanced_service_detection()
        self.cve_lookup()
        self.subdomain_enum()
        self.web_bruteforce()
        self.http_info()
        self.detailed_https_info()
        self.dns_lookup()
        self.dns_enum()
        self.whois_lookup()
        self.os_detection()
        self.log(f"{Fore.BLUE}--- PenTest Complete ---{Style.RESET_ALL}")

def main():
    print(BANNER)
    parser = argparse.ArgumentParser(description="PenTest CLI Tool (Automated)")
    parser.add_argument("target", help="Target IP or domain")
    parser.add_argument("--ports", help="Comma-separated TCP ports to scan", default=None)
    parser.add_argument("--udp-ports", help="Comma-separated UDP ports to scan", default=None)
    parser.add_argument("--scan-speed", help="Scan speed in seconds (default: 0.5)", type=float, default=0.5)
    parser.add_argument("--log", help="Log output to file", default=None)
    args = parser.parse_args()

    ports = [int(p.strip()) for p in args.ports.split(",") if p.strip().isdigit()] if args.ports else None
    udp_ports = [int(p.strip()) for p in args.udp_ports.split(",") if p.strip().isdigit()] if args.udp_ports else None

    tool = PenTestTool(
        args.target,
        ports=ports,
        udp_ports=udp_ports,
        scan_speed=args.scan_speed,
        log_file=args.log
    )
    tool.run_all()

if __name__ == "__main__":
    main()
